---
title: "Data analysis"
author: "Ross Cunning"
date: "2025-02-07"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(msm)  # Needed for the Delta Method
```

Check site 3072 / IRN3-210 -- no corals counted?

# Import data
```{r}
# Port Everglades site metadata
sites <- readxl::read_xlsx("data/site_metadata.xlsx") %>%
  janitor::clean_names() %>%
  rename(penip_site = site,
         site = drm_site_id,
         latitude = lat,
         longitude = lon)

# Data from main DRM surveys
adults <- read_csv("data/DRM_broward_corals.csv") %>%
  mutate(site = parse_number(site)) %>%
  left_join(sites)

# Juveniles
juv <- read_csv("data/DRM_broward_juveniles.csv") %>%
  mutate(site = parse_number(site)) %>%
  left_join(sites)

# Presence-absence of species of special concern
pa <- read_csv("data/DRM_broward_spp_special_concern.csv") %>%
  mutate(site = parse_number(site)) %>%
  left_join(sites)

# Additional bonus data collected only on Port Everglades surveys
## Transects 1 and 2 -- juvenile coral counts for all taxa, acer/ofav/conch/tires p/a
t1t2bonus <- read_csv("data/T1_T2_bonus_data.csv") %>%
  janitor::clean_names() %>%
  rename(penip_site = site) %>%
  mutate(penip_site = replace_na(penip_site, "NA")) %>%
  mutate(transect_num = parse_number(transect)) %>%
  left_join(sites)
## Transects 3 and 4 -- sediment depth and acer/ofav/conch/tires p/a
t3t4bonus <- read_csv("data/T3_T4_bonus_data.csv") %>%
  janitor::clean_names() %>%
  rename(penip_site = site) %>%
  mutate(penip_site = replace_na(penip_site, "NA")) %>%
  mutate(transect_num = parse_number(transect)) %>%
  left_join(sites)

# Full site metadata
drmsitemd <- adults %>%
  distinct(site, date, latitude, longitude)
penipsitemd <- sites %>%
  distinct(site, date, latitude, longitude, penip_site, reef, direction, distance_m)

# Combine drm site and penip site metadata
allsitemd <- full_join(drmsitemd, penipsitemd, by = c("site", "date", "latitude", "longitude")) %>%
  group_by(site) %>%
  mutate(across(c(penip_site, reef, direction, distance_m), ~ coalesce(.x, first(na.omit(.x))))) %>%
  ungroup() %>%
  distinct(site, .keep_all = TRUE)

# Plot sites
allsitemd %>%
  ggplot(aes(x = longitude, y = latitude, color = !is.na(penip_site))) +
  geom_point()

allsitemd %>% count(!is.na(penip_site))
```

# Combine data
```{r}
# Get counts of adult corals (>4cm)
## Need to separately consider species that were searched for on all four transects, vs. those only searched on t1 and t2
# Define the list of species searched for on transects 3 and 4
searched_species <- c("CNAT", "DSTO", "DLAB", "MMEA", "MANG", "MALI", "MFER", "MLAM", "PCLI", "PSTR")

# Get all site-transect combinations (ensuring transects 3 and 4 exist for each site)
all_sites <- unique(adults$site)
all_transects <- expand.grid(site = all_sites, transect_num = c(1, 2, 3, 4))  # Include all transects

# Process the data
adult.counts <- adults %>%
  drop_na(species) %>%
  group_by(site, transect_num, species) %>%
  summarize(count = n(), .groups = "drop") %>%
  pivot_wider(names_from = species, values_from = count) %>%  # Do NOT fill missing values yet
  full_join(all_transects, by = c("site", "transect_num")) %>%  # Ensure all transects exist
  
  # Replace NAs correctly:
  mutate(across(
    -c(site, transect_num),
    ~ case_when(
      transect_num %in% c(1, 2) & is.na(.) ~ 0,  # Set ALL species to 0 for T1 & T2
      transect_num %in% c(3, 4) & is.na(.) & cur_column() %in% searched_species ~ 0,  # Only searched species get 0 for T3 & T4
      transect_num %in% c(3, 4) & is.na(.) ~ NA,  # Keep non-searched species as NA for T3 & T4
      TRUE ~ .  # Keep existing values
    )
  )) %>%
  mutate(class = ">4cm")


# Add class <4cm for juveniles
drmjuvs <- juv %>%
  select(site, transect_num, ends_with("ct")) %>%
  rename(MCAV = montastraea_ct, MUSS = mussinae_ct, FAVI = faviinae_ct, MEAN = meandrinidae_ct)

t1t2juvs <- t1t2bonus %>%
  select(site, transect_num, starts_with("small")) %>%
  rename_with(~ toupper(gsub("^small_", "", .x)), starts_with("small_"))

alljuv <- full_join(drmjuvs, t1t2juvs, by = c("site", "transect_num")) %>%
    mutate(class = "<4cm")

# 9 sites missing juvenile data -- still waiting on JS to send... (these were the sites she removed from overall DRM dataset)


# Combine all adult and juvenile count data
allcounts <- bind_rows(adult.counts, alljuv) %>%
  full_join(allsitemd)


# Pivot to long form
counts_long <- allcounts %>% 
  pivot_longer(
    cols = matches("^[A-Z]{4}$", ignore.case = FALSE),  # Select columns with exactly four uppercase letters
    names_to = "taxon",
    values_to = "count"
  ) %>%
  drop_na(count)  # Drop missing values (species not searched for on a given transect, since zeros already assigned above)
```

# Summarize total corals per site
```{r}
# Get PENIP subset
penip <- filter(counts_long, !is.na(penip_site)) %>% 
  mutate(taxclass = paste0(taxon, class))

# total counts for each taxon/class per site, and total area searched for each (since diff no. transects)
taxclass_totals <- penip %>%
  group_by(site, latitude, longitude, reef, direction, distance_m, taxon, class, taxclass) %>%
  summarize(n = sum(count), area = n() * 10) %>%  # 10 m2 per counted transect
  ungroup() %>%
  mutate(n_per_m2 = n / area)

# summarize site-level total coral density
total_corals_per_m2 <- taxclass_totals %>%
    group_by(site, latitude, longitude, reef, direction, distance_m) %>%
    summarize(total_per_m2 = sum(n_per_m2)) %>%  # Sum per-mÂ² densities
    ungroup()

# Average total coral density per square meter across all sites
mean(total_corals_per_m2$total_per_m2)
# 2.58 corals per square meter

# Plot density across sites
ggplot(total_corals_per_m2, aes(x = longitude, y = latitude, size = total_per_m2)) +
  geom_point(alpha = 0.5)
```


# Negative binomial GLM
```{r}
# MODEL CORAL COUNTS at the site level, using totals per taxon-size class per site (added up across transects)
# offset(log(area)) has to be included because of the different number of transects used for different taxon-size class groups

# Fit a Negative Binomial GLM
mod_nb <- MASS::glm.nb(n ~ taxon * class + offset(log(area)), data = taxclass_totals)

# Generate new data only for existing taxon-size class combinations
newdata_1 <- taxclass_totals %>%
  distinct(taxon, class) %>%  # Keep only observed taxon-class combinations
  mutate(area = 1)  # Set area to 1 for density predictions

# Get predicted values & standard errors (log scale)
preds_nb <- predict(mod_nb, newdata_1, type = "link", se.fit = TRUE)

# Compute both total coral density & taxon-size class-specific densities in one step
results_nb <- newdata_1 %>%
  mutate(
    fit = exp(preds_nb$fit),                    # Convert fitted values to response scale
    fit_se = exp(preds_nb$fit) * preds$se.fit,   # Convert SE using the Delta Method
    fit_var = (fit * preds_nb$se.fit)^2,         # Variance propagation
    lower_95CI = exp(preds_nb$fit - 1.96 * preds_nb$se.fit),  # Lower CI
    upper_95CI = exp(preds_nb$fit + 1.96 * preds_nb$se.fit)   # Upper CI
  )

# Compute total coral density + confidence intervals
total_ci_nb <- results_nb %>%
  summarize(
    total_density = sum(fit),
    total_se = sqrt(sum(fit_var)),
    lower_95CI = exp(log(total_density) - 1.96 * (total_se / total_density)),
    upper_95CI = exp(log(total_density) + 1.96 * (total_se / total_density))
  )

total_ci_nb
# 2.62 total corals per m2 (95%CI 2.23-3.07)

# Extract and plot taxon-size-class-specific densities
taxclass_ci_nb <- results_nb %>%
  dplyr::select(taxon, class, fit, fit_se, lower_95CI, upper_95CI)

# Set a lower limit for visualization
lower_limit <- 1e-4

ggplot(taxclass_ci_nb, aes(x = taxon, y = fit, color = class)) +
  geom_point() +
  geom_errorbar(aes(
    ymin = pmax(fit / exp(1.96 * fit_se / fit), lower_limit),  # Clip ymin at lower limit
    ymax = pmax(fit * exp(1.96 * fit_se / fit), lower_limit)   # Clip ymax at lower limit
  ), width = 0.2) +
  scale_y_log10(limits = c(lower_limit, 5)) +  # Set lower limit, allow auto upper limit
  coord_flip() +
  labs(y = "Estimated Coral Density (per mÂ²)", x = "Taxon", color = "Size Class") +
  theme_minimal() +
  labs(title = "Negative binomial GLM")
  
```


# Try zero-inflated negative binomial
```{r}
library(pscl)

mod_zinb <- zeroinfl(n ~ taxon * class + offset(log(area)), 
                      data = taxclass_totals, 
                      dist = "negbin",
                      link = "logit",
                      start = list(count = rep(0, length(coef(mod_nb))),
                                   zero = rep(0, length(coef(mod_nb)))))  # Use stable starting values

summary(mod_zinb)

library(lmtest)

lrtest(mod_nb, mod_zinb)  # Likelihood Ratio Test
# Suggests zinb better than nb


# Generate new data only for existing taxon-size class combinations
newdata_1 <- taxclass_totals %>%
  distinct(taxon, class) %>%  # Keep only observed taxon-class combinations
  mutate(area = 1)  # Set area to 1 for density predictions

# Get predicted values & standard errors (log scale)
preds_zinb <- predict(mod_zinb, newdata_1, type = "response")

# Function to generate predictions for bootstrapping
boot_pred <- function(data, indices) {
  boot_model <- update(mod_zinb, data = data[indices, ])
  predict(boot_model, newdata = newdata_1, type = "response")
}

# Perform bootstrapping (100 resamples)
boot_res <- boot(data = taxclass_totals, statistic = boot_pred, R = 100)

# Compute standard errors from bootstrap resamples
pred_se <- apply(boot_res$t, 2, sd)


# Compute taxon-class-specific densities with confidence intervals
results_zinb <- newdata_1 %>%
  mutate(
    fit = preds_zinb,                     # Fitted values (response scale)
    fit_se = pred_se,                      # Bootstrapped SE
    lower_95CI = fit - 1.96 * fit_se,      # Compute lower CI
    upper_95CI = fit + 1.96 * fit_se       # Compute upper CI
  )

# Print taxon-size class densities
results_zinb

# Compute total coral density + confidence intervals
total_ci_zinb <- results_zinb %>%
  summarize(
    total_density = sum(fit),
    total_se = sqrt(sum(fit_se^2)),  # Propagate SE correctly
    lower_95CI = total_density - 1.96 * total_se,
    upper_95CI = total_density + 1.96 * total_se
  )

# Print total coral density estimate
total_ci_zinb
# 3.18 corals per m2 (2.73-3.63 CI)


# Extract and plot taxon-size-class-specific densities
taxclass_ci_zinb <- results_zinb %>%
  dplyr::select(taxon, class, fit, fit_se, lower_95CI, upper_95CI)

# Set a lower limit for visualization
lower_limit <- 1e-4

ggplot(taxclass_ci_zinb, aes(x = taxon, y = fit, color = class)) +
  geom_point() +
  geom_errorbar(aes(
    ymin = pmax(fit / exp(1.96 * fit_se / fit), lower_limit),  # Clip ymin at lower limit
    ymax = pmax(fit * exp(1.96 * fit_se / fit), lower_limit)   # Clip ymax at lower limit
  ), width = 0.2) +
  scale_y_log10(limits = c(lower_limit, 5)) +  # Set lower limit, allow auto upper limit
  coord_flip() +
  labs(y = "Estimated Coral Density (per mÂ²)", x = "Taxon", color = "Size Class") +
  theme_minimal() +
  labs(title = "ZI Negative binomial GLM")
  
```


# Bayesian zerio-inflated negative binomial with random site effects
```{r}
# Bayesian ZINB model with random site effects
library(brms)
library(future)

# ðŸš€ Optimize parallel execution
n_cores <- 4  # Use 4 cores for chains
n_threads <- 5  # Use 5 threads per chain (total CPU usage = 4 * 5 = 10 cores)
options(mc.cores = n_cores)
future::plan(multisession)

mod_zinb_bayes <- brm(
  bf(count ~ taxclass + (1 | site), zi ~ taxclass),
  family = zero_inflated_negbinomial(),
  data = penip,
  chains = n_cores,  # 4 chains
  cores = n_cores,  # 4 parallel processes
  threads = threading(n_threads),  # 5 threads per chain (full CPU utilization)
  iter = 2500, warmup = 750,  # Optimized iteration balance
  thin = 2,
  control = list(adapt_delta = 0.90, max_treedepth = 10),
  backend = "cmdstanr"
)

# Model summary
summary(mod_zinb_bayes)

# Generate posterior fitted values for each taxon-size class
fitted_taxclass_zinb <- fitted(mod_zinb_bayes, summary = TRUE) %>%
  as_tibble() %>%
  bind_cols(dplyr::select(penip, taxclass)) %>%
  rename(fit = Estimate, fit_lower = Q2.5, fit_upper = Q97.5, fit_se = Est.Error) %>%
  dplyr::select(taxclass, fit, fit_se, fit_lower, fit_upper) %>%
  distinct(taxclass, .keep_all = TRUE)

# Compute total coral density per mÂ² (sum over taxon-size classes)
total_density_zinb <- fitted_taxclass_zinb %>%
  summarize(
    total_fit = sum(fit),
    total_se = sqrt(sum(fit_se^2)),  # Correct SE propagation
    total_lower = sum(fit_lower),
    total_upper = sum(fit_upper)
  )

# Print total coral density per transect
total_density_zinb
# 30.7 per transect == 3.07 per square meter (1.70-5.27 95%CI)

# Convert densities from per transect to per m2 (divide by 10m2)
fitted_taxclass_zinb_per_m2 <- fitted_taxclass_zinb %>%
  mutate(across(c(fit, fit_se, fit_lower, fit_upper), ~ . / 10)) %>%
  mutate(taxon = substr(taxclass, 1, 4),
         class = substr(taxclass, 5, 8))

# Plot
lower_limit <- 1e-4
ggplot(fitted_taxclass_zinb_per_m2, aes(x = taxon, y = fit, color = class)) +
  geom_point() +
  geom_errorbar(aes(
    ymin = pmax(fit / exp(1.96 * fit_se / fit), lower_limit),  # Clip ymin at lower limit
    ymax = pmax(fit * exp(1.96 * fit_se / fit), lower_limit)   # Clip ymax at lower limit
  ), width = 0.2) +
  scale_y_log10(limits = c(lower_limit, 5)) +  # Set lower limit, allow auto upper limit
  coord_flip() +
  labs(y = "Estimated Coral Density (per mÂ²)", x = "Taxon", color = "Size Class") +
  theme_minimal() +
  labs(title = "Bayesian Zinb with site random")


# Sum densities across size classes?
fitted_taxon_zinb_per_m2_ag <- fitted_taxclass_zinb_per_m2 %>%
  group_by(taxon) %>%
  summarize(
    fit = sum(fit),  # Sum densities
    fit_se = sqrt(sum(fit_se^2)),  # Correct SE propagation (variance addition)
    lower_95CI = fit - 1.96 * fit_se,  # Compute lower CI
    upper_95CI = fit + 1.96 * fit_se   # Compute upper CI
  ) %>%
  ungroup() %>%
  mutate(taxon = fct_reorder(taxon, fit)) 

ggplot(fitted_taxon_zinb_per_m2_ag, aes(x = taxon, y = fit)) +
  geom_point() +
  geom_errorbar(aes(
    ymin = pmax(fit / exp(1.96 * fit_se / fit), lower_limit),  # Clip ymin at lower limit
    ymax = pmax(fit * exp(1.96 * fit_se / fit), lower_limit)   # Clip ymax at lower limit
  ), width = 0.2) +
  scale_y_log10(limits = c(lower_limit, 5)) +  # Set lower limit, allow auto upper limit
  coord_flip() +
  labs(y = "Estimated Coral Density (per mÂ²)", x = "Taxon", color = "Size Class") +
  theme_minimal() +
  labs(title = "Bayesian Zinb with site random")

```



# AGGREGATE TAXA
# Aggregate certain taxa
```{r}
counts_long_ag <- counts_long %>%
  mutate(taxon = case_when(taxon %in% c("PPOR", "PFUR", "PDIV") ~ "PBRA",
                           taxon %in% c("OFAV", "OANN", "OFRA") ~ "ORBI",
                           taxon %in% c("MALI", "MFER", "MYCE", "SCUB", "SCOL") ~ "MUSS",
                           taxon %in% c("CNAT", "DLAB", "FFRA", "MARE", "PSTR", "PCLI") ~ "FAVI",
                           taxon %in% c("DCYL", "DSTO", "EFAS", "MMEA") ~ "MEAN",
                           taxon %in% c("AFRA", "AGAR", "AAGA") ~ "AGAR",
                           taxon %in% c("MAUR", "MDEC") ~ "MADR",
                           TRUE ~ taxon))
counts_long_ag %>% group_by(taxon) %>% summarize(tot = sum(count)) %>% arrange(tot)


# Get PENIP subset
penip_ag <- filter(counts_long_ag, !is.na(penip_site)) %>% 
  mutate(taxclass = paste0(taxon, class))

# total counts for each taxon/class per site, and total area searched for each (since diff no. transects)
taxclass_totals_ag <- penip_ag %>%
  group_by(site, latitude, longitude, reef, direction, distance_m, taxon, class, taxclass) %>%
  summarize(n = sum(count), area = n() * 10) %>%  # 10 m2 per counted transect
  ungroup() %>%
  mutate(n_per_m2 = n / area)

library(pscl)

mod_zinb <- zeroinfl(n ~ taxclass + offset(log(area)), 
                      data = taxclass_totals_ag, 
                      dist = "negbin",
                      link = "logit",
                      start = list(count = rep(0, length(coef(mod_nb))),
                                   zero = rep(0, length(coef(mod_nb)))))  # Use stable starting values

summary(mod_zinb)


# Generate new data only for existing taxon-size class combinations
newdata_1 <- taxclass_totals_ag %>%
  distinct(taxon, class, taxclass) %>%  # Keep only observed taxon-class combinations
  mutate(area = 1)  # Set area to 1 for density predictions

# Get predicted values & standard errors (log scale)
preds_zinb <- predict(mod_zinb, newdata_1, type = "response")

# Function to generate predictions for bootstrapping
boot_pred <- function(data, indices) {
  boot_model <- update(mod_zinb, data = data[indices, ])
  predict(boot_model, newdata = newdata_1, type = "response")
}

# Perform bootstrapping (100 resamples)
boot_res <- boot(data = taxclass_totals_ag, statistic = boot_pred, R = 100)

# Compute standard errors from bootstrap resamples
pred_se <- apply(boot_res$t, 2, sd)


# Compute taxon-class-specific densities with confidence intervals
results_zinb <- newdata_1 %>%
  mutate(
    fit = preds_zinb,                     # Fitted values (response scale)
    fit_se = pred_se,                      # Bootstrapped SE
    lower_95CI = fit - 1.96 * fit_se,      # Compute lower CI
    upper_95CI = fit + 1.96 * fit_se       # Compute upper CI
  )

# Print taxon-size class densities
results_zinb

# Compute total coral density + confidence intervals
total_ci_zinb <- results_zinb %>%
  summarize(
    total_density = sum(fit),
    total_se = sqrt(sum(fit_se^2)),  # Propagate SE correctly
    lower_95CI = total_density - 1.96 * total_se,
    upper_95CI = total_density + 1.96 * total_se
  )

# Print total coral density estimate
total_ci_zinb
# 3.03 corals per m2 (2.59-3.47 CI)


# Extract and plot taxon-size-class-specific densities
taxclass_ci_zinb <- results_zinb %>%
  dplyr::select(taxon, class, fit, fit_se, lower_95CI, upper_95CI)

# Set a lower limit for visualization
lower_limit <- 1e-4

ggplot(taxclass_ci_zinb, aes(x = taxon, y = fit, color = class)) +
  geom_point() +
  geom_errorbar(aes(
    ymin = pmax(fit / exp(1.96 * fit_se / fit), lower_limit),  # Clip ymin at lower limit
    ymax = pmax(fit * exp(1.96 * fit_se / fit), lower_limit)   # Clip ymax at lower limit
  ), width = 0.2) +
  scale_y_log10(limits = c(lower_limit, 5)) +  # Set lower limit, allow auto upper limit
  coord_flip() +
  labs(y = "Estimated Coral Density (per mÂ²)", x = "Taxon", color = "Size Class") +
  theme_minimal() +
  labs(title = "ZI Negative binomial GLM")
```

# Try Bayesian ZINB with site effects with aggregated data
```{r}
# Bayesian ZINB model with random site effects
library(brms)
library(future)

# ðŸš€ Optimize parallel execution
n_cores <- 4  # Use 4 cores for chains
n_threads <- 5  # Use 5 threads per chain (total CPU usage = 4 * 5 = 10 cores)
options(mc.cores = n_cores)
future::plan(multisession)

mod_zinb_bayes <- brm(
  bf(count ~ taxclass + (1 | site), zi ~ taxclass),
  family = zero_inflated_negbinomial(),
  data = penip_ag,
  chains = n_cores,  # 4 chains
  cores = n_cores,  # 4 parallel processes
  threads = threading(n_threads),  # 5 threads per chain (full CPU utilization)
  iter = 2500, warmup = 750,  # Optimized iteration balance
  thin = 2,
  control = list(adapt_delta = 0.90, max_treedepth = 10),
  backend = "cmdstanr"
)

# Model summary
summary(mod_zinb_bayes)

# Generate posterior fitted values for each taxon-size class
fitted_taxclass_zinb <- fitted(mod_zinb_bayes, summary = TRUE) %>%
  as_tibble() %>%
  bind_cols(dplyr::select(penip_ag, taxclass)) %>%
  rename(fit = Estimate, fit_lower = Q2.5, fit_upper = Q97.5, fit_se = Est.Error) %>%
  dplyr::select(taxclass, fit, fit_se, fit_lower, fit_upper) %>%
  distinct(taxclass, .keep_all = TRUE)

# Compute total coral density per mÂ² (sum over taxon-size classes)
total_density_zinb <- fitted_taxclass_zinb %>%
  summarize(
    total_fit = sum(fit),
    total_se = sqrt(sum(fit_se^2)),  # Correct SE propagation
    total_lower = sum(fit_lower),
    total_upper = sum(fit_upper)
  )

# Print total coral density per transect
total_density_zinb
# 28.8 per transect == 2.88 per square meter (1.57-4.94 95%CI)

# Convert densities from per transect to per m2 (divide by 10m2)
fitted_taxclass_zinb_per_m2 <- fitted_taxclass_zinb %>%
  mutate(across(c(fit, fit_se, fit_lower, fit_upper), ~ . / 10)) %>%
  mutate(taxon = substr(taxclass, 1, 4),
         class = substr(taxclass, 5, 8))

# Plot
lower_limit <- 1e-4
ggplot(fitted_taxclass_zinb_per_m2, aes(x = taxon, y = fit, color = class)) +
  geom_point() +
  geom_errorbar(aes(
    ymin = pmax(fit / exp(1.96 * fit_se / fit), lower_limit),  # Clip ymin at lower limit
    ymax = pmax(fit * exp(1.96 * fit_se / fit), lower_limit)   # Clip ymax at lower limit
  ), width = 0.2) +
  scale_y_log10(limits = c(lower_limit, 5)) +  # Set lower limit, allow auto upper limit
  coord_flip() +
  labs(y = "Estimated Coral Density (per mÂ²)", x = "Taxon", color = "Size Class") +
  theme_minimal() +
  labs(title = "Bayesian Zinb with site random")


# Sum densities across size classes
fitted_taxon_zinb_per_m2_ag <- fitted_taxclass_zinb_per_m2 %>%
  group_by(taxon) %>%
  summarize(
    fit = sum(fit),  # Sum densities
    fit_se = sqrt(sum(fit_se^2)),  # Correct SE propagation (variance addition)
    lower_95CI = fit - 1.96 * fit_se,  # Compute lower CI
    upper_95CI = fit + 1.96 * fit_se   # Compute upper CI
  ) %>%
  ungroup() %>%
  mutate(taxon = fct_reorder(taxon, fit)) 

ggplot(fitted_taxon_zinb_per_m2_ag, aes(x = taxon, y = fit)) +
  geom_point() +
  geom_errorbar(aes(
    ymin = pmax(fit / exp(1.96 * fit_se / fit), lower_limit),  # Clip ymin at lower limit
    ymax = pmax(fit * exp(1.96 * fit_se / fit), lower_limit)   # Clip ymax at lower limit
  ), width = 0.2) +
  scale_y_log10(limits = c(lower_limit, 5)) +  # Set lower limit, allow auto upper limit
  coord_flip() +
  labs(y = "Estimated Coral Density (per mÂ²)", x = "Taxon", color = "Size Class") +
  theme_minimal() +
  labs(title = "Bayesian Zinb with site random")



# PLOT ALL
# Add type label to size-class-specific estimates
fitted_taxclass_zinb_per_m2 <- fitted_taxclass_zinb_per_m2 %>%
  mutate(type = "Size Class")

# Add type label to taxon totals
fitted_taxon_zinb_per_m2_ag <- fitted_taxon_zinb_per_m2_ag %>%
  mutate(type = "Taxon Total", class = "Total")  # Assign "Total" as class for legend clarity

# Combine both datasets
fitted_combined <- bind_rows(fitted_taxclass_zinb_per_m2, fitted_taxon_zinb_per_m2_ag)

# Reorder taxon levels based on total density (highest first)
fitted_combined <- fitted_combined %>%
  mutate(taxon = fct_reorder(taxon, fit))

lower_limit <- 1e-4  # Define lower clipping limit

ggplot(fitted_combined, aes(x = taxon, y = fit, color = class, shape = type)) +
  geom_point(aes(size = type), 
             position = position_dodge(width = 0.2), alpha = 0.6) +  
  geom_errorbar(aes(
    ymin = pmax(fit / exp(1.96 * fit_se / fit), lower_limit),  # Clip ymin
    ymax = pmax(fit * exp(1.96 * fit_se / fit), lower_limit)), width = 0, position = position_dodge(width = 0.2),
    alpha = 0.6) +  
  scale_y_log10(limits = c(lower_limit, 5)) +  
  scale_size_manual(values = c("Taxon Total" = 4, "Size Class" = 2.5)) +  # Larger points for totals
  scale_shape_manual(values = c("Taxon Total" = 15, "Size Class" = 16)) +  # Different shape for totals
  coord_flip() +  
  labs(y = "Estimated Coral Density (per mÂ²)", x = "Taxon", 
       color = "Size Class", shape = "Estimate Type", size = "Estimate Type") +  
  theme_minimal() +  
  labs(title = "Bayesian ZINB Model: Taxon & Size-Class Coral Densities")


```










#### parking lot below VVV


```{r}




# Maybe keep at transect level?
mod_qp <- glm.nb(count ~ taxon:class + offset(log(area)), family = quasipoisson(link = "log"), data = penip)

penip$predicted_counts <- predict(mod_qp, type = "response")
penip$predicted_density <- penip$predicted_counts / penip$area
predicted_summary <- penip %>%
  group_by(taxon, class) %>%
  summarize(mean_density = mean(predicted_density))
print(predicted_summary)
ggplot(predicted_summary, aes(x = taxon, y = mean_density, color = class)) +
  geom_point() +
  ylim(0,0.6)

sum(predicted_summary$mean_density)
# 1.14 corals per square meter

emm <- emmeans(mod_qp, ~ taxon:class, type = "response")
# Extract the estimated means and standard errors
emm_results <- as.data.frame(emm)

# Compute estimated counts per unit area
emm_results$estimated_density <- emm_results$response / mean(penip$area)

# View results
print(emm_results)

###### following pom-dredge methods

library(lme4)
mod_qp <- glmer(count ~ taxclass + offset(log(area)) + (1|site/transect_num), 
                family = "poisson", data = penip)
# get fitted responses
newdata_1 <- penip %>%
  tidyr::expand(taxclass, area = 1)
newdata_1$fit <- predict(mod_qp, newdata_1, type = "response", re.form = NA)

newdata_1 <- newdata_1 %>%
  mutate(taxon = substr(taxclass, 1, 4),
         class = substr(taxclass, 5, nchar(taxclass)))
ggplot(newdata_1, aes(x = taxon, y = fit, color = class)) +
  geom_point() +
  ylim(0,0.6)

sum(newdata_1$fit)
#0.96 corals per square meter
```



# First things to look at
# factors to consider: reef habitat, direction from channel, distance from channel

# total number of adult corals
# size frequency of adult corals by species
# total number of small corals
# ESA corals especially - ACER/OFAV
# need total area of NRC/IR/MR/etc with distance from channel moving north and south of channel as a function of distance
# Rugosity?



